<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Grover Reflections (JS)</title>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      messageStyle: "none"
    });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG"></script>
  <script src="https://cdn.plot.ly/plotly-3.3.0.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 12px;
      font-family: sans-serif;
    }

    #opinfo {
      margin: 6px 0 10px 0;
      font-size: 14px;
      line-height: 1.35;
      color: #111827;
    }

    #grover {
      width: 100%;
      height: 640px;
    }

    .explainer {
      max-width: 960px;
      margin: 28px auto 40px auto;
      line-height: 1.55;
      color: #1f2937;
      font-size: 15px;
    }

    .explainer h2 {
      margin: 0 0 12px 0;
      font-size: 20px;
      color: #111827;
    }

    .explainer h3 {
      margin: 22px 0 8px 0;
      font-size: 17px;
      color: #111827;
    }

    .explainer p {
      margin: 8px 0;
    }

    .explainer ul {
      margin: 8px 0 8px 16px;
      padding: 0;
    }

    .callout {
      max-width: 960px;
      margin: 10px auto 8px auto;
      padding: 10px 14px;
      border-radius: 6px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .callout .icon {
      font-size: 16px;
      line-height: 1;
    }

    .callout.slider {
      background: #EFF6FF;
      border: 1px solid #BFDBFE;
      color: #1E3A8A;
    }

    .callout.refresh {
      background: #FEF3C7;
      border: 1px solid #FCD34D;
      color: #92400E;
    }
  </style>
</head>

<body>
  <div id="slider-hint" class="callout slider">
    <span class="icon">üéöÔ∏è</span>
    <span>Read the explainer below and then use the slider to explore how the system evolves step by step.</span>
  </div>
  <div id="refresh-hint" class="callout refresh">
    <span class="icon">‚ö†Ô∏è</span>
    <span>If anything looks off, refresh the page and use the slider again.</span>
  </div>
  <div id="grover"></div>
  <div id="opinfo" style="text-align:center; margin-top:6px;"></div>

  <div id="explainer" class="explainer">
    <p><strong>Note:</strong> This demo shows a 3-qubit state with the marked item $\lvert 0000 \rangle$; the same
      reflection steps generalize to any number of qubits and any single marked item.</p>
    <h2>Grover's Algorithm in Brief</h2>
    <p>Grover's search finds a marked item with only <span>$O(\sqrt{N})$</span> oracle calls (vs. <span>$O(N)$</span>
      classically) by alternating two reflections: the phase oracle (flips the marked state's phase) and the diffusion
      operator (reflects amplitudes about their mean). Repeating these steps rotates the state toward the marked item,
      boosting its measurement probability. Too many iterations rotate past the optimum; with one marked item, the best
      count is <span>$\approx \tfrac{\pi}{4}\sqrt{N}$</span>. With multiple marked items, the optimal count changes (see
      Appendix E).</p>

    <h3>Searching Problem</h3>
    <p>Given data indexed by <span>$x \in \{0,1\}^n$</span> and a Boolean function <span>$f : \{0,1\}^n \to
        \{0,1\}$</span>, find the marked item <span>$x_*$</span> with <span>$f(x_*) = 1$</span>. The phase-oracle form
      (see Appendix A):</p>
    <p style="text-align:center;">$$
      O_f^\pm \lvert x \rangle =
      \begin{cases}
      -\lvert x \rangle, & x = x_* \\
      \lvert x \rangle, & \text{otherwise}
      \end{cases}
      $$</p>

    <h3>Oracles as Reflections</h3>
    <p>A reflection about <span>$\lvert 0^n \rangle$</span> is (see Appendix B)</p>
    <p style="text-align:center;">$$
      S_0^\pm = I - 2\lvert 0^n \rangle\langle 0^n \rvert, \qquad
      S_0^\pm \lvert x \rangle =
      \begin{cases}
      -\lvert x \rangle, & x = 0^n \\
      \lvert x \rangle, & \text{otherwise}
      \end{cases}
      $$</p>

    <h3>Diffusion Operator</h3>
    <p>Reflect about the uniform superposition <span>$\lvert +^n \rangle$</span> (Hadamard basis) (see Appendix C):</p>
    <p style="text-align:center;">$$
      S_+^\pm = I - 2\lvert +^n \rangle\langle +^n \rvert, \qquad
      -S_+^\pm\!\left(\sum_x \alpha_x \lvert x \rangle\right) = \sum_x (2\mu - \alpha_x)\lvert x \rangle, \;
      \mu=\tfrac{1}{2^n}\sum_x
      \alpha_x
      $$</p>
    <p>It can be implemented as <span>$S_+^\pm = H^{\otimes n} S_0^\pm H^{\otimes n}$</span>.</p>

    <h3>Two-Dimensional Picture</h3>
    <p>Group all unmarked states into <span>$\lvert x_\perp \rangle$</span>, with the marked state <span>$\lvert x_*
        \rangle$</span>
      orthogonal to it (see Appendix E):</p>
    <p style="text-align:center;">$$
      \lvert x_\perp \rangle = \sum_{x \ne x_*} \tfrac{1}{\sqrt{N-1}} \lvert x \rangle, \qquad
      \lvert +^n \rangle = \sin\theta \lvert x_* \rangle + \cos\theta \lvert x_\perp \rangle, \quad \sin\theta =
      \tfrac{1}{\sqrt{N}}
      $$</p>

    <h3>Grover Iterations as Rotations</h3>
    <p>Define <span>$\lvert \psi_k \rangle = (-S_+^\pm O_f^\pm)^k \lvert +^n \rangle$</span> and <span>$\lvert \psi_k'
        \rangle = O_f^\pm
        \lvert \psi_k \rangle$</span>. Each oracle+diffusion block rotates the state by <span>$2\theta$</span> in the
      plane
      spanned by <span>$\{\lvert x_* \rangle, \lvert x_\perp \rangle\}$</span>. After <span>$k$</span> iterations, the
      angle from
      <span>$\lvert +^n \rangle$</span> is <span>$(2k+1)\theta$</span>. The optimum is reached when <span>$(2k+1)\theta
        \approx
        \tfrac{\pi}{2}$</span>, giving (see Appendix E)
    </p>
    <p style="text-align:center;">$$
      k \approx \frac{\pi}{4\theta} - \frac{1}{2} \;\approx\; \frac{\pi}{4}\sqrt{N} - \tfrac{1}{2}.
      $$</p>
  </div>
  <script>
    // Parameters
    const n = 4;
    const N = 2 ** n;
    const numIterations = 8;
    const frameMs = 550;
    const theta = Math.asin(1 / Math.sqrt(N));

    const axisLen = 1.15;
    const plusDir = [Math.cos(theta), Math.sin(theta)];
    const thetaArcR = 0.35;
    const thetaArcPath = `M ${thetaArcR} 0 A ${thetaArcR} ${thetaArcR} 0 0 1 ${(Math.cos(theta) * thetaArcR).toFixed(4)} ${(Math.sin(theta) * thetaArcR).toFixed(4)}`;

    const amplitudeData = (angle) => {
      const ampMarked = Math.sin(angle);
      const ampOther = Math.cos(angle) / Math.sqrt(N - 1);
      const amps = Array.from({ length: N }, (_, i) => (i === 0 ? ampMarked : ampOther));
      const mean = amps.reduce((a, b) => a + b, 0) / N;
      return { amps, mean };
    };

    const probData = (angle) => {
      const pMarked = Math.sin(angle) ** 2;
      return [pMarked, 1 - pMarked];
    };

    const xTicks = Array.from({ length: N }, (_, i) => i.toString(2).padStart(n, "0"));

    // Color palette for iterations (inspired by the reference image)
    const iterationColors = [
      "#1f2937", // Initial state (dark gray/black)
      "#DC2626", // Iteration 1 (red)
      "#059669", // Iteration 2 (green)
      "#2563EB", // Iteration 3 (blue)
      "#7C3AED", // Iteration 4 (purple)
      "#D97706", // Iteration 5 (amber)
      "#0891B2", // Iteration 6 (cyan)
      "#BE185D", // Iteration 7 (pink)
      "#4338CA", // Iteration 8 (indigo)
    ];

    // Pre-compute all state angles for history tracking
    const stateHistory = [];
    stateHistory.push({ angle: theta, label: "$\\lvert +^{n} \\rangle$", iteration: 0, isOracle: false });
    for (let i = 0; i < numIterations; i++) {
      const current = theta + 2 * theta * i;
      const oracle = -current;
      stateHistory.push({ angle: oracle, label: `$|\\psi_{${i + 1}}'\\rangle$`, iteration: i + 1, isOracle: true });
      const diffusion = 2 * theta - oracle;
      stateHistory.push({ angle: diffusion, label: `$|\\psi_{${i + 1}}\\rangle$`, iteration: i + 1, isOracle: false });
    }

    const buildFrame = (frameIndex) => {
      const currentState = stateHistory[frameIndex];
      const angle = currentState.angle;
      const [pMarked, pOther] = probData(angle);
      const { amps, mean } = amplitudeData(angle);
      const probsSq = amps.map((a) => a * a);

      // Previous-step data for faint/dashed outlines
      const prevState = frameIndex > 0 ? stateHistory[frameIndex - 1] : null;
      const prevAngle = prevState ? prevState.angle : null;
      const { amps: prevAmps, mean: prevMean } = prevAngle !== null ? amplitudeData(prevAngle) : { amps: Array(N).fill(0), mean: 0 };
      const [pMarkedPrev, pOtherPrev] = prevAngle !== null ? probData(prevAngle) : [0, 0];

      // Build annotations for all previous states + current state
      const annotations = [
        // Geometric plot axis labels
        { x: 1.15, y: -0.08, text: "$|x_{\\perp}\\rangle$", showarrow: false, font: { size: 14, color: "#374151" }, xref: "x", yref: "y" },
        { x: 0.08, y: 1.18, text: "$|x^{*}\\rangle$", showarrow: false, font: { size: 14, color: "#374151" }, xref: "x", yref: "y" },
        // Reflection direction |+^n>
        { x: plusDir[0] * axisLen * 0.75, y: plusDir[1] * axisLen * 1.15, text: "$|+^{n}\\rangle$", showarrow: false, font: { size: 13, color: "#111827" }, xref: "x", yref: "y" },
        { x: plusDir[0] * axisLen, y: plusDir[1] * axisLen, ax: 0, ay: 0, xref: "x", yref: "y", axref: "x", ayref: "y", showarrow: true, arrowhead: 2, arrowsize: 2, arrowwidth: 3, arrowcolor: "#111827", text: "" },
        { x: plusDir[0] * thetaArcR * 1.1, y: plusDir[1] * thetaArcR * 0.7, text: "$\\theta$", showarrow: false, font: { size: 12, color: "#111827" }, xref: "x", yref: "y" },
        // Subplot titles
        { x: 0.14, y: 1.06, xref: "paper", yref: "paper", text: "<b>State Space</b>", showarrow: false, font: { size: 15, color: "#1f2937" } },
        { x: 0.42, y: 1.06, xref: "paper", yref: "paper", text: "<b>Probabilities</b>", showarrow: false, font: { size: 15, color: "#1f2937" } },
        { x: 0.78, y: 1.06, xref: "paper", yref: "paper", text: "<b>Amplitudes</b>", showarrow: false, font: { size: 15, color: "#1f2937" } },
      ];

      // Add arrows for all states up to current frame
      // Diffusion states = solid arrows, Oracle states = dashed arrows
      const extraShapes = [];
      // Dashed outlines for previous-step bars (probability and amplitude)
      const prevShapes = [];

      if (prevState) {
        const probHeights = [pMarkedPrev, pOtherPrev];
        for (let i = 0; i < probHeights.length; i++) {
          const xCenter = i;
          prevShapes.push({
            type: "rect",
            xref: "x2",
            yref: "y2",
            x0: xCenter - 0.4,
            x1: xCenter + 0.4,
            y0: 0,
            y1: probHeights[i],
            line: { color: "#6B7280", width: 1.2, dash: "dash" },
            fillcolor: "rgba(0,0,0,0)"
          });
        }

        for (let i = 0; i < prevAmps.length; i++) {
          const xCenter = i;
          prevShapes.push({
            type: "rect",
            xref: "x3",
            yref: "y3",
            x0: xCenter - 0.4,
            x1: xCenter + 0.4,
            y0: 0,
            y1: prevAmps[i],
            line: { color: "#6B7280", width: 1.0, dash: "dash" },
            fillcolor: "rgba(0,0,0,0)"
          });
        }
      }

      for (let i = 0; i <= frameIndex; i++) {
        const state = stateHistory[i];
        const color = iterationColors[state.iteration] || iterationColors[iterationColors.length - 1];
        const x = Math.cos(state.angle);
        const y = Math.sin(state.angle);
        const isCurrent = (i === frameIndex);

        // Calculate text offset direction (outward from origin)
        const labelOffset = 0.12;
        const labelX = x * (1 + labelOffset);
        const labelY = y * (1 + labelOffset);

        // Skip drawing the initial |+^n> arrow here (we already render a permanent black vector)
        if (state.iteration === 0) {
          continue;
        }

        // Add black dashed connecting arrow from previous state to this state (if not the first state)
        if (i > 0) {
          const prevState = stateHistory[i - 1];
          const prevX = Math.cos(prevState.angle);
          const prevY = Math.sin(prevState.angle);

          // Dashed line part (shape)
          extraShapes.push({
            type: "line",
            x0: prevX, y0: prevY,
            x1: x, y1: y,
            xref: "x", yref: "y",
            line: { color: "#374151", width: 1.5, dash: "dot" }
          });

          // Arrowhead at the tip (annotation)
          // Position arrowhead slightly back from the tip to show direction
          const dx = x - prevX;
          const dy = y - prevY;
          const len = Math.sqrt(dx * dx + dy * dy);
          const arrowStartX = x - (dx / len) * 0.12;
          const arrowStartY = y - (dy / len) * 0.12;

          annotations.push({
            x: x, y: y,
            ax: arrowStartX, ay: arrowStartY,
            xref: "x", yref: "y", axref: "x", ayref: "y",
            showarrow: true,
            arrowhead: 2,
            arrowsize: 1.2,
            arrowwidth: 1.5,
            arrowcolor: "#374151",
            text: ""
          });
        }

        if (state.isOracle) {
          // Oracle states shown as dashed arrows from origin
          extraShapes.push({
            type: "line",
            x0: 0, y0: 0,
            x1: x, y1: y,
            xref: "x", yref: "y",
            line: { color: color, width: isCurrent ? 2.5 : 1.5, dash: "dash" }
          });

          // Add arrowhead at the tip
          annotations.push({
            x: x, y: y,
            ax: x * 0.85, ay: y * 0.85,
            xref: "x", yref: "y", axref: "x", ayref: "y",
            showarrow: true, arrowhead: 2,
            arrowsize: isCurrent ? 2 : 1.2,
            arrowwidth: isCurrent ? 2 : 1.5,
            arrowcolor: color,
            text: "",
            font: { size: 12, color: color }
          });

          // Add label at the tip (persist across frames)
          annotations.push({
            x: labelX, y: labelY,
            xref: "x", yref: "y",
            showarrow: false,
            text: state.label,
            font: { size: isCurrent ? 12 : 10, color: color }
          });
        } else {
          // Diffusion states (and initial state) shown as solid arrows
          // Arrow from origin to tip
          annotations.push({
            x: x, y: y, ax: 0, ay: 0,
            xref: "x", yref: "y", axref: "x", ayref: "y",
            showarrow: true,
            arrowhead: 2,
            arrowsize: isCurrent ? 2 : 1.5,
            arrowwidth: isCurrent ? 3 : 2,
            arrowcolor: color,
            text: "",
            font: { size: isCurrent ? 13 : 11, color: color }
          });

          // Add label at the tip (separate annotation)
          const labelText = state.iteration === 0 ? "" : state.label;
          if (labelText) {
            annotations.push({
              x: labelX, y: labelY,
              xref: "x", yref: "y",
              showarrow: false,
              text: labelText,
              font: { size: isCurrent ? 13 : 11, color: color }
            });
          }
        }
      }

      // Combine base shapes with extra shapes (oracle lines + connecting lines)
      const frameShapes = [...shapes, ...extraShapes, ...prevShapes];

      return {
        name: stateHistory[frameIndex].iteration === 0 ? "0 |+^n>" :
          (stateHistory[frameIndex].isOracle ?
            `${stateHistory[frameIndex].iteration}a oracle` :
            `${stateHistory[frameIndex].iteration}b diffusion`),
        data: [
          {
            type: "bar",
            x: ["marked $|x^{*}\\rangle$", "$|x_{\\perp}\\rangle$"],
            y: [pMarkedPrev, pOtherPrev],
            marker: {
              color: ["rgba(242,107,56,0.15)", "rgba(203,213,225,0.15)"],
              line: { color: "rgba(0,0,0,0)", width: 0 }
            },
            opacity: prevState ? 1 : 0,
            hoverinfo: "skip",
            xaxis: "x2",
            yaxis: "y2",
            name: "Last step",
            legendgroup: "step",
            showlegend: true
          },
          {
            y: [pMarked, pOther]
          },
          {
            type: "bar",
            x: xTicks,
            y: prevAmps,
            marker: {
              color: ["rgba(242,107,56,0.15)"].concat(Array(N - 1).fill("rgba(203,213,225,0.15)")),
              line: { color: "rgba(0,0,0,0)", width: 0 }
            },
            hoverinfo: "skip",
            opacity: prevState ? 1 : 0,
            xaxis: "x3",
            yaxis: "y3",
            name: "Last step",
            legendgroup: "step",
            showlegend: false
          },
          {
            x: xTicks,
            y: amps,
            customdata: probsSq
          },
          {
            x: xTicks,
            y: Array(N).fill(mean),
            type: "scatter",
            mode: "lines",
            line: { color: "#10B981", dash: "dash" },
            hoverinfo: "skip",
            name: "Mean amplitude",
            showlegend: true
          },
        ],
        layout: { annotations, shapes: frameShapes }
      };
    };

    // Initial data
    const startAngle = theta;
    const { amps: amps0, mean: mean0 } = amplitudeData(startAngle);
    const probs0 = probData(startAngle);

    const data = [
      {
        type: "bar",
        x: ["marked $|x^{*}\\rangle$", "$|x_{\\perp}\\rangle$"],
        y: [0, 0],
        marker: {
          color: ["rgba(242,107,56,0.15)", "rgba(203,213,225,0.15)"],
          line: { color: "rgba(0,0,0,0)", width: 0 }
        },
        opacity: 0,
        hoverinfo: "skip",
        xaxis: "x2",
        yaxis: "y2",
        name: "Last step",
        legendgroup: "step",
        showlegend: true
      },
      {
        type: "bar",
        x: ["marked $|x^{*}\\rangle$", "$|x_{\\perp}\\rangle$"],
        y: probs0,
        marker: { color: ["#F26B38", "#CBD5E1"], line: { color: "#111827", width: 1.4 } },
        hovertemplate: "%{y:.3f}",
        xaxis: "x2",
        yaxis: "y2",
        name: "Current step",
        legendgroup: "step",
        showlegend: true
      },
      {
        type: "bar",
        x: xTicks,
        y: Array(N).fill(0),
        marker: {
          color: ["rgba(242,107,56,0.15)"].concat(Array(N - 1).fill("rgba(203,213,225,0.15)")),
          line: { color: "rgba(0,0,0,0)", width: 0 }
        },
        hoverinfo: "skip",
        opacity: 0,
        xaxis: "x3",
        yaxis: "y3",
        name: "Last step",
        legendgroup: "step",
        showlegend: false
      },
      {
        type: "bar",
        x: xTicks,
        y: amps0,
        customdata: amps0.map((a) => a * a),
        marker: { color: ["#F26B38"].concat(Array(N - 1).fill("#CBD5E1")), line: { color: "#111827", width: 1.1 } },
        hovertemplate: "state %{x}<br>amp %{y:.3f}<br>prob %{customdata:.3f}",
        xaxis: "x3",
        yaxis: "y3",
        name: "Current step",
        legendgroup: "step",
        showlegend: false
      },
      {
        type: "scatter",
        mode: "lines",
        x: xTicks,
        y: Array(N).fill(mean0),
        line: { color: "#10B981", dash: "dash" },
        hoverinfo: "skip",
        xaxis: "x3",
        yaxis: "y3",
        name: "Mean amplitude",
        showlegend: true
      }
    ];

    // Shapes for axes and |+^n> reflection line
    const shapes = [
      { type: "line", x0: -axisLen, y0: 0, x1: axisLen, y1: 0, line: { color: "#6B7280", width: 1.5 } },
      { type: "line", x0: 0, y0: -axisLen, x1: 0, y1: axisLen, line: { color: "#6B7280", width: 1.5, dash: "dash" } },
      { type: "path", path: thetaArcPath, line: { color: "#111827", width: 1.4 } },
    ];

    // Layout
    const layout = {
      height: 620,
      width: 1400,
      margin: { t: 80, r: 40, l: 60, b: 90 },
      bargap: 0.25,
      barmode: "overlay",
      showlegend: true,
      legend: { x: 0.82, y: 1.12, orientation: "h", font: { size: 13 } },
      title: { text: "Grover's Search as Alternating Reflections", x: 0.5, font: { size: 20 } },
      xaxis: { anchor: "y", domain: [0.0, 0.28], range: [-1.25, 1.25], showgrid: false, zeroline: false },
      yaxis: { anchor: "x", domain: [0, 1], range: [-1.25, 1.25], showgrid: false, zeroline: false, scaleanchor: "x", scaleratio: 1 },
      xaxis2: { anchor: "y2", domain: [0.34, 0.50] },
      yaxis2: { anchor: "x2", domain: [0, 1], range: [0, 1], title: { text: "Probability" } },
      xaxis3: { anchor: "y3", domain: [0.56, 1], title: { text: "State" }, type: "category" },
      yaxis3: { anchor: "x3", domain: [0, 1], range: [-1, 1], title: { text: "Amplitude" } },
      shapes,
      annotations: [
        // Geometric plot axis labels
        { x: 1.15, y: -0.08, text: "|x‚üÇ‚ü©", showarrow: false, font: { size: 14, color: "#374151" }, xref: "x", yref: "y" },
        { x: 0.08, y: 1.18, text: "|x*‚ü©", showarrow: false, font: { size: 14, color: "#374151" }, xref: "x", yref: "y" },
        // Reflection line label
        { x: plusDir[0] * axisLen * 0.75, y: plusDir[1] * axisLen * 1.15, text: "|+‚Åø‚ü©", showarrow: false, font: { size: 13, color: "#10B981" }, xref: "x", yref: "y" },
        // Subplot titles
        { x: 0.14, y: 1.06, xref: "paper", yref: "paper", text: "<b>State Space</b>", showarrow: false, font: { size: 15, color: "#1f2937" } },
        { x: 0.42, y: 1.06, xref: "paper", yref: "paper", text: "<b>Probabilities</b>", showarrow: false, font: { size: 15, color: "#1f2937" } },
        { x: 0.78, y: 1.06, xref: "paper", yref: "paper", text: "<b>Amplitudes</b>", showarrow: false, font: { size: 15, color: "#1f2937" } },
        // Current step info (will be updated in frames)
        { x: 0.5, y: -0.02, xref: "paper", yref: "paper", text: `Œ∏ = ${(theta * 180 / Math.PI).toFixed(2)}¬∞ ‚Äî Start at |+‚Åø‚ü©`, showarrow: false, font: { size: 14, color: "#6b7280" } },
      ],
      sliders: [],
      updatemenus: []
    };

    // Frames - build using state history
    const frames = [];
    for (let i = 0; i < stateHistory.length; i++) {
      frames.push(buildFrame(i));
    }

    layout.sliders = [
      {
        active: 0,
        len: 0.9,
        x: 0.05,
        y: -0.05,
        currentvalue: { prefix: "Step: " },
        steps: frames.map(f => ({
          label: f.name,
          method: "animate",
          args: [[f.name], { mode: "immediate", frame: { duration: frameMs, redraw: true }, transition: { duration: 180 } }]
        }))
      }
    ];

    const opinfo = document.getElementById('opinfo');
    const formatOpText = (frameIndex) => {
      const state = stateHistory[frameIndex];
      if (state.iteration === 0) {
        return `\\text{Init: } |\\psi_0\\rangle = |+^n\\rangle`;
      }
      const k = state.iteration;
      if (state.isOracle) {
        return `\\text{Step ${k}a: } O_f^\\pm \\text{ (phase oracle)}\\\\ \\text{Before: } |\\psi_{${k - 1}}\\rangle\\\\ \\text{After: } |\\psi_{${k}}'\\rangle = O_f^\\pm |\\psi_{${k - 1}}\\rangle`;
      }
      return `\\text{Step ${k}b: } -S_+^\\pm \\text{ (diffusion)}\\\\ \\text{Before: } |\\psi_{${k}}'\\rangle\\\\ \\text{After: } |\\psi_{${k}}\\rangle = -S_+^\\pm |\\psi_{${k}}'\\rangle`;
    };

    const setOpInfo = (frameIndex) => {
      const body = formatOpText(frameIndex);
      const state = stateHistory[frameIndex];
      const k = state.iteration;
      const condensed = (() => {
        if (k === 0) {
          return `|\\psi_0\\rangle = |+^n\\rangle`;
        }
        if (state.isOracle) {
          return `|\\psi_${k}'\\rangle = O_f^\\pm (-S_+^\\pm O_f^\\pm)^{${k - 1}} |+^n\\rangle`;
        }
        return `|\\psi_${k}\\rangle = (-S_+^\\pm O_f^\\pm)^{${k}} |+^n\\rangle`;
      })();

      opinfo.innerHTML = `$$${body}\\\\ \\text{Condensed: } ${condensed}$$`;
      if (window.MathJax && window.MathJax.Hub) {
        window.MathJax.Hub.Queue(["Typeset", window.MathJax.Hub, opinfo]);
      }
    };

    Plotly.newPlot('grover', data, layout, { responsive: true }).then(() => {
      Plotly.addFrames('grover', frames);

      // Custom handlers to properly update annotations when slider/animation changes
      // This fixes the issue where annotations don't disappear when going backwards
      const groverDiv = document.getElementById('grover');

      // Track current frame to properly update on any change
      let lastFrameIndex = 0;

      const updateToFrame = (frameIndex) => {
        if (frameIndex !== undefined && frameIndex !== lastFrameIndex) {
          lastFrameIndex = frameIndex;
          const frame = frames[frameIndex];
          if (frame && frame.layout) {
            // Use relayout to properly replace annotations and shapes
            Plotly.relayout('grover', {
              annotations: frame.layout.annotations,
              shapes: frame.layout.shapes
            });
            setOpInfo(frameIndex);
          }
        }
      };

      // Listen for slider changes
      groverDiv.on('plotly_sliderchange', function (eventData) {
        updateToFrame(eventData.slider.active);
      });

      // Also listen for animation frame changes
      groverDiv.on('plotly_animatingframe', function (eventData) {
        // Find the frame index by name
        const frameName = eventData.name;
        const frameIndex = frames.findIndex(f => f.name === frameName);
        if (frameIndex >= 0) {
          updateToFrame(frameIndex);
        }
      });

      // Ensure MathJax renders the explainer section
      if (window.MathJax && window.MathJax.Hub) {
        window.MathJax.Hub.Queue(["Typeset", window.MathJax.Hub, document.getElementById('explainer')]);
      }

      // Initialize op info
      setOpInfo(0);
    });
  </script>
</body>

</html>